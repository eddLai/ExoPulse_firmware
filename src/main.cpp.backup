#include <Arduino.h>
#include <SPI.h>
#include <mcp_can.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/semphr.h"

/*
 * LK-TECH Dual Motor Status Reader - FreeRTOS Optimized
 * Purpose: READ TWO motors (ID 1 and ID 2) status data with high-frequency updates
 *
 * Motor: LK-TECH M Series (MS/MF/MG/MH)
 * CAN Baud Rate: 1 Mbps
 * Motor IDs: 1 and 2
 */

// MCP2515 SPI Configuration
constexpr int CAN_CS   = 5;
constexpr int SPI_SCK  = 18;
constexpr int SPI_MISO = 19;
constexpr int SPI_MOSI = 23;

MCP_CAN CAN(CAN_CS);

constexpr int LED_PIN = 2;
constexpr uint8_t MOTOR_ID_1 = 1;  // First motor ID
constexpr uint8_t MOTOR_ID_2 = 2;  // Second motor ID

// CAN IDs (0x140 + Motor ID)
const uint32_t CAN_ID_1 = 0x140 + MOTOR_ID_1;
const uint32_t CAN_ID_2 = 0x140 + MOTOR_ID_2;

// Update rate configuration
constexpr uint32_t UPDATE_INTERVAL_MS = 100;  // 10Hz update rate

// Read-only commands (no motor control)
enum MotorReadCommand : uint8_t {
    READ_PID_PARAMS         = 0x30,
    READ_ACCELERATION       = 0x33,
    READ_ENCODER            = 0x90,
    READ_MULTI_ANGLE        = 0x92,
    READ_SINGLE_ANGLE       = 0x94,
    READ_STATUS_1_ERROR     = 0x9A,
    READ_STATUS_2           = 0x9C,
    READ_STATUS_3           = 0x9D,
};

// Motor status data structure
struct MotorStatus {
    uint8_t motorID;         // Motor ID (1 or 2)
    int8_t temperature;      // °C
    uint16_t voltage;        // 0.1V/LSB
    uint8_t errorState;      // Error flags
    int16_t torqueCurrent;   // iq: -2048~2048 → -33A~33A
    int16_t speed;           // dps (degrees per second)
    uint16_t encoder;        // 0~16383 (14-bit)
    int64_t motorAngle;      // 0.01°/LSB (multi-turn cumulative)
    uint32_t timestamp;      // millis() when read
};

// FreeRTOS objects
QueueHandle_t motorDataQueue;
SemaphoreHandle_t canMutex;
TaskHandle_t canReadTaskHandle;
TaskHandle_t serialOutputTaskHandle;

// Send a read command to specific motor
bool sendReadCommand(uint32_t canID, uint8_t cmd) {
    uint8_t txData[8] = {cmd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

    if (xSemaphoreTake(canMutex, pdMS_TO_TICKS(10)) == pdTRUE) {
        byte rc = CAN.sendMsgBuf(canID, 0, 8, txData);
        xSemaphoreGive(canMutex);
        return (rc == CAN_OK);
    }
    return false;
}

// Read CAN response from motor (non-blocking)
bool readMotorResponse(uint32_t expectedID, uint8_t expectedCmd, uint8_t* rxData, uint32_t timeoutMs = 50) {
    uint32_t startTime = millis();

    while (millis() - startTime < timeoutMs) {
        if (xSemaphoreTake(canMutex, pdMS_TO_TICKS(5)) == pdTRUE) {
            if (CAN.checkReceive() == CAN_MSGAVAIL) {
                unsigned long rxId;
                byte len;

                CAN.readMsgBuf(&rxId, &len, rxData);
                xSemaphoreGive(canMutex);

                // Check if response is from our motor
                if (rxId == expectedID && rxData[0] == expectedCmd) {
                    return true;
                }
            } else {
                xSemaphoreGive(canMutex);
            }
        }
        vTaskDelay(pdMS_TO_TICKS(1));
    }

    return false;  // Timeout
}

// Read motor status 2 (temperature, torque current, speed, encoder)
bool readMotorStatus2(uint32_t canID, MotorStatus& status) {
    if (!sendReadCommand(canID, READ_STATUS_2)) {
        return false;
    }

    uint8_t rxData[8];
    if (!readMotorResponse(canID, READ_STATUS_2, rxData, 50)) {
        return false;
    }

    status.temperature = (int8_t)rxData[1];
    status.torqueCurrent = (int16_t)(rxData[2] | (rxData[3] << 8));
    status.speed = (int16_t)(rxData[4] | (rxData[5] << 8));
    status.encoder = (uint16_t)(rxData[6] | (rxData[7] << 8));

    return true;
}

// Read motor status 1 (temperature, voltage, error flags)
bool readMotorStatus1(uint32_t canID, MotorStatus& status) {
    if (!sendReadCommand(canID, READ_STATUS_1_ERROR)) {
        return false;
    }

    uint8_t rxData[8];
    if (!readMotorResponse(canID, READ_STATUS_1_ERROR, rxData, 50)) {
        return false;
    }

    status.temperature = (int8_t)rxData[1];
    status.voltage = (uint16_t)(rxData[3] | (rxData[4] << 8));
    status.errorState = rxData[7];

    return true;
}

// Read multi-turn angle
bool readMultiTurnAngle(uint32_t canID, MotorStatus& status) {
    if (!sendReadCommand(canID, READ_MULTI_ANGLE)) {
        return false;
    }

    uint8_t rxData[8];
    if (!readMotorResponse(canID, READ_MULTI_ANGLE, rxData, 50)) {
        return false;
    }

    status.motorAngle = (int64_t)rxData[1]
                      | ((int64_t)rxData[2] << 8)
                      | ((int64_t)rxData[3] << 16)
                      | ((int64_t)rxData[4] << 24)
                      | ((int64_t)rxData[5] << 32)
                      | ((int64_t)rxData[6] << 40);

    return true;
}

// Read complete status for one motor
bool readMotorComplete(uint8_t motorID, uint32_t canID, MotorStatus& status) {
    status.motorID = motorID;

    bool success = true;

    if (!readMotorStatus1(canID, status)) {
        success = false;
    }

    if (!readMotorStatus2(canID, status)) {
        success = false;
    }

    if (!readMultiTurnAngle(canID, status)) {
        success = false;
    }

    if (success) {
        status.timestamp = millis();
    }

    return success;
}

// CAN Reading Task (High Priority) - Runs on Core 1
void canReadTask(void *parameter) {
    MotorStatus status1 = {0};
    MotorStatus status2 = {0};

    while (true) {
        // Read Motor 1
        if (readMotorComplete(MOTOR_ID_1, CAN_ID_1, status1)) {
            xQueueSend(motorDataQueue, &status1, 0);
            digitalWrite(LED_PIN, HIGH);
        }

        // Small delay between motors
        vTaskDelay(pdMS_TO_TICKS(10));

        // Read Motor 2
        if (readMotorComplete(MOTOR_ID_2, CAN_ID_2, status2)) {
            xQueueSend(motorDataQueue, &status2, 0);
            digitalWrite(LED_PIN, LOW);
        }

        // Wait before next read cycle (10Hz = 100ms total)
        vTaskDelay(pdMS_TO_TICKS(90));
    }
}

// Serial Output Task (Lower Priority) - Runs on Core 0
void serialOutputTask(void *parameter) {
    MotorStatus status;
    uint32_t outputCount1 = 0;
    uint32_t outputCount2 = 0;

    while (true) {
        // Wait for data from queue (blocking with timeout)
        if (xQueueReceive(motorDataQueue, &status, pdMS_TO_TICKS(200)) == pdTRUE) {
            // Output in compact format for GUI parsing
            Serial.print("[");
            Serial.print(status.timestamp);
            Serial.print("] M:");
            Serial.print(status.motorID);
            Serial.print(" T:");
            Serial.print(status.temperature);
            Serial.print(" V:");
            Serial.print(status.voltage * 0.1, 1);
            Serial.print(" I:");
            float actualCurrent = (float)status.torqueCurrent * 33.0 / 2048.0;
            Serial.print(actualCurrent, 2);
            Serial.print(" S:");
            Serial.print(status.speed);
            Serial.print(" E:");
            Serial.print(status.encoder);
            Serial.print(" A:");
            float angleDeg = (float)status.motorAngle * 0.01;
            Serial.print(angleDeg, 2);
            Serial.print(" ERR:0x");
            Serial.print(status.errorState, HEX);
            Serial.println();

            // Track output counts per motor
            if (status.motorID == MOTOR_ID_1) {
                outputCount1++;
            } else if (status.motorID == MOTOR_ID_2) {
                outputCount2++;
            }

            // Print detailed status every 10 reads per motor (1 second at 10Hz)
            if ((status.motorID == MOTOR_ID_1 && outputCount1 % 10 == 0) ||
                (status.motorID == MOTOR_ID_2 && outputCount2 % 10 == 0)) {
                Serial.print("--- Motor ");
                Serial.print(status.motorID);
                Serial.println(" Status (detailed) ---");
                Serial.print("Temperature:     ");
                Serial.print(status.temperature);
                Serial.println(" °C");

                Serial.print("Voltage:         ");
                Serial.print(status.voltage * 0.1, 1);
                Serial.println(" V");

                Serial.print("Torque Current:  ");
                Serial.print(actualCurrent, 2);
                Serial.print(" A  (raw=");
                Serial.print(status.torqueCurrent);
                Serial.println(")");

                Serial.print("Speed:           ");
                Serial.print(status.speed);
                Serial.println(" dps");

                Serial.print("Encoder:         ");
                Serial.print(status.encoder);
                Serial.println(" (0~16383)");

                Serial.print("Multi-turn Angle:");
                Serial.print(angleDeg, 2);
                Serial.print(" °  (");
                Serial.print(angleDeg / 360.0, 2);
                Serial.println(" turns)");

                Serial.print("Error State:     0x");
                Serial.print(status.errorState, HEX);
                if (status.errorState & 0x01) Serial.print(" [LOW_VOLTAGE]");
                if (status.errorState & 0x08) Serial.print(" [OVER_TEMP]");
                Serial.println();
                Serial.println("--------------------\n");
            }
        }
    }
}

void setup() {
    Serial.begin(115200);
    delay(1000);

    Serial.println("\n========================================");
    Serial.println("   LK-TECH Dual Motor Status Reader");
    Serial.println("   FreeRTOS Optimized - 10Hz");
    Serial.println("========================================\n");

    pinMode(LED_PIN, OUTPUT);
    digitalWrite(LED_PIN, LOW);

    // Initialize SPI
    Serial.println("[1] Initializing SPI...");
    SPI.begin(SPI_SCK, SPI_MISO, SPI_MOSI);
    Serial.println("    SPI initialized");

    // Initialize MCP2515 at 1Mbps
    Serial.println("\n[2] Initializing MCP2515...");
    Serial.println("    Trying 1MBPS @ 8MHz...");

    byte result = CAN.begin(MCP_ANY, CAN_1000KBPS, MCP_8MHZ);

    if (result != CAN_OK) {
        Serial.println("    Failed! Trying 1MBPS @ 16MHz...");
        result = CAN.begin(MCP_ANY, CAN_1000KBPS, MCP_16MHZ);
    }

    if (result != CAN_OK) {
        Serial.println("\n[ERROR] MCP2515 initialization FAILED!");
        while (1) {
            digitalWrite(LED_PIN, !digitalRead(LED_PIN));
            delay(200);
        }
    }

    Serial.println("    MCP2515 initialized successfully!");

    // Set to NORMAL mode
    Serial.println("\n[3] Setting NORMAL mode...");
    CAN.setMode(MCP_NORMAL);
    Serial.println("    Mode set to NORMAL");

    // Create FreeRTOS objects
    Serial.println("\n[4] Creating FreeRTOS tasks...");

    // Create queue for motor data (capacity: 20 items for both motors)
    motorDataQueue = xQueueCreate(20, sizeof(MotorStatus));
    if (motorDataQueue == NULL) {
        Serial.println("    [ERROR] Failed to create queue!");
        while(1);
    }

    // Create mutex for CAN bus access
    canMutex = xSemaphoreCreateMutex();
    if (canMutex == NULL) {
        Serial.println("    [ERROR] Failed to create mutex!");
        while(1);
    }

    // Create CAN reading task (high priority, core 1)
    xTaskCreatePinnedToCore(
        canReadTask,
        "CAN_Read",
        4096,
        NULL,
        3,
        &canReadTaskHandle,
        1
    );

    // Create Serial output task (lower priority, core 0)
    xTaskCreatePinnedToCore(
        serialOutputTask,
        "Serial_Output",
        4096,
        NULL,
        1,
        &serialOutputTaskHandle,
        0
    );

    Serial.println("    Tasks created successfully!");
    Serial.println("\n[OK] Dual Motor Status Reader ready!");
    Serial.println("========================================");
    Serial.print("Monitoring Motors: ID=");
    Serial.print(MOTOR_ID_1);
    Serial.print(" and ID=");
    Serial.println(MOTOR_ID_2);
    Serial.print("Update rate: ");
    Serial.print(1000 / UPDATE_INTERVAL_MS);
    Serial.println(" Hz per motor\n");
}

void loop() {
    // Main loop is now empty - everything handled by FreeRTOS tasks
    vTaskDelay(pdMS_TO_TICKS(1000));
}
