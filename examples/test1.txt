#include <SPI.h>

#include "mcp_can.h"

  

constexpr uint8_t CAN_CS_PIN   = 5;

constexpr uint8_t MOTOR_ID     = 1;

  

constexpr uint32_t CAN_BAUDRATE = CAN_1000KBPS;

constexpr uint8_t  MCP_CLOCK    = MCP_8MHZ;

  

constexpr int SPI_SCK  = 18;

constexpr int SPI_MISO = 19;

constexpr int SPI_MOSI = 23;

constexpr int SPI_CS   = CAN_CS_PIN;

  

constexpr uint32_t STATUS_PERIOD_MS = 50;

  

MCP_CAN CAN(CAN_CS_PIN);

  

float   g_targetAngleDeg = 0.0f;

float   g_targetSpeedDps = 0.0f;

float   g_targetIq_A     = 0.0f;

  

bool g_sendPos    = false;

bool g_sendSpeed  = false;

bool g_sendTorque = false;

  

char   serialBuf[32];

uint8_t serialIdx = 0;

  

bool motorSendFrame(uint8_t motorId, const uint8_t d[8]) {

  uint32_t canId = 0x140 + motorId;

  byte rc = CAN.sendMsgBuf(canId, 0, 8, (uint8_t*)d);

  return rc == CAN_OK;

}

  

bool motorSetTorqueIq_A(float Iq_A) {

  const float MAX_ABS_IQ_A = 3.0f;

  if (Iq_A >  MAX_ABS_IQ_A) Iq_A =  MAX_ABS_IQ_A;

  if (Iq_A < -MAX_ABS_IQ_A) Iq_A = -MAX_ABS_IQ_A;

  float scale = 2000.0f / 32.0f;

  int16_t iqControl = (int16_t)(Iq_A * scale);

  uint8_t d[8] = {0xA1,0,0,0,0,0,0,0};

  d[4] = iqControl & 0xFF;

  d[5] = (iqControl >> 8) & 0xFF;

  return motorSendFrame(MOTOR_ID, d);

}

  

bool motorSetSpeed(float speed_dps) {

  const float MAX_ABS_SPEED_DPS = 50.0f;

  if (speed_dps >  MAX_ABS_SPEED_DPS) speed_dps =  MAX_ABS_SPEED_DPS;

  if (speed_dps < -MAX_ABS_SPEED_DPS) speed_dps = -MAX_ABS_SPEED_DPS;

  int32_t sp = (int32_t)(speed_dps * 100.0f);

  uint8_t d[8] = {0xA2,0,0,0,0,0,0,0};

  d[4] = sp & 0xFF;

  d[5] = (sp >> 8) & 0xFF;

  d[6] = (sp >> 16) & 0xFF;

  d[7] = (sp >> 24) & 0xFF;

  return motorSendFrame(MOTOR_ID, d);

}

  

bool motorSetPosition(float angle_deg) {

  int32_t p = (int32_t)(angle_deg * 100.0f);

  uint8_t d[8] = {0xA3,0,0,0,0,0,0,0};

  d[4] = p & 0xFF;

  d[5] = (p >> 8) & 0xFF;

  d[6] = (p >> 16) & 0xFF;

  d[7] = (p >> 24) & 0xFF;

  return motorSendFrame(MOTOR_ID, d);

}

  

bool motorSetZeroHere() {

  uint8_t d[8] = {0x19,0,0,0,0,0,0,0};

  return motorSendFrame(MOTOR_ID, d);

}

  

bool motorRequestState2() {

  uint8_t d[8] = {0x9C,0,0,0,0,0,0,0};

  return motorSendFrame(MOTOR_ID, d);

}

  

void handleSerial() {

  while (Serial.available()) {

    char c = (char)Serial.read();

    if (c == '\r') continue;

    if (c == '\n') {

      serialBuf[serialIdx] = '\0';

      if (serialIdx > 0) {

        char cmd = serialBuf[0];

        if (cmd >= 'a' && cmd <= 'z') cmd -= 32;

        if (cmd == 'Z') {

          bool ok = motorSetZeroHere();

          Serial.println(ok ? "Zero cmd sent (0x19)" : "Zero cmd FAILED");

        } else if (cmd == 'P' || cmd == 'S' || cmd == 'T') {

          char *p = serialBuf + 1;

          while (*p == ' ' || *p == '\t') ++p;

          float v = atof(p);

          if (cmd == 'P') {

            g_targetAngleDeg = v;

            g_sendPos = true;

          } else if (cmd == 'S') {

            g_targetSpeedDps = v;

            g_sendSpeed = true;

          } else if (cmd == 'T') {

            g_targetIq_A = v;

            g_sendTorque = true;

          }

        } else {

          Serial.println("Use P<deg>, S<dps>, T<Iq_A>, Z");

        }

      }

      serialIdx = 0;

    } else {

      if (serialIdx < sizeof(serialBuf) - 1) {

        serialBuf[serialIdx++] = c;

      }

    }

  }

}

  

void processTx() {

  if (g_sendPos) {

    g_sendPos = false;

    motorSetPosition(g_targetAngleDeg);

  }

  if (g_sendSpeed) {

    g_sendSpeed = false;

    motorSetSpeed(g_targetSpeedDps);

  }

  if (g_sendTorque) {

    g_sendTorque = false;

    motorSetTorqueIq_A(g_targetIq_A);

  }

}

  

void processRx() {

  while (CAN.checkReceive() == CAN_MSGAVAIL) {

    unsigned long rxId;

    byte len;

    uint8_t buf[8];

    CAN.readMsgBuf(&rxId, &len, buf);

    if (rxId == (0x140 + MOTOR_ID) && len == 8 && buf[0] == 0x9C) {

      int8_t  temperature = (int8_t)buf[1];

      int16_t iq_raw      = (int16_t)(buf[2] | (buf[3] << 8));

      int16_t speed_raw   = (int16_t)(buf[4] | (buf[5] << 8));

      uint16_t encoder    = (uint16_t)(buf[6] | (buf[7] << 8));

      uint16_t encoder14  = encoder & 0x3FFF;

      float iq_A      = (float)iq_raw * 33.0f / 2048.0f;

      float speed_dps = (float)speed_raw;

      float angle_deg = (float)encoder14 * 360.0f / 16384.0f;

      Serial.print("ang=");

      Serial.print(angle_deg, 2);

      Serial.print(" deg, sp=");

      Serial.print(speed_dps, 1);

      Serial.print(" dps, iq=");

      Serial.print(iq_A, 3);

      Serial.print(" A, T=");

      Serial.println(temperature);

    }

  }

}

  

void setup() {

  Serial.begin(230400);

  while (!Serial) {}

  Serial.println("CAN test. Cmds: P<deg>, S<dps>, T<Iq_A>, Z");

  SPI.begin(SPI_SCK, SPI_MISO, SPI_MOSI, SPI_CS);

  if (CAN.begin(MCP_STDEXT, CAN_BAUDRATE, MCP_CLOCK) != CAN_OK) {

    Serial.println("CAN init FAILED");

    while (true) delay(500);

  }

  CAN.setMode(MCP_NORMAL);

  Serial.println("CAN init OK");

  delay(100);

}

  

void loop() {

  static uint32_t lastStatus = 0;

  uint32_t now = millis();

  handleSerial();

  processTx();

  if (now - lastStatus >= STATUS_PERIOD_MS) {

    motorRequestState2();

    lastStatus = now;

  }

  processRx();

}